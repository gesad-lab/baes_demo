import os
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Dict, Any, List
import logging

try:
    from bae_academic_system.config import Config
except ModuleNotFoundError:
    from config import Config

logger = logging.getLogger(__name__)

class ManagedSystemManager:
    """
    Manages the creation, structure, and updates of the unified managed system
    that contains all entities generated by the BAE framework.
    """
    
    def __init__(self):
        self.managed_system_path = Config.get_managed_system_path()
        self.managed_system_path.mkdir(parents=True, exist_ok=True)
        logger.info(f"ðŸ—ï¸  Managed System initialized at: {self.managed_system_path}")
    
    def ensure_managed_system_structure(self) -> bool:
        """Ensure the complete managed system directory structure exists."""
        try:
            self._create_directory_structure()
            self._create_base_files()
            self._ensure_virtual_environment()
            self._install_dependencies()
            logger.info("âœ… Managed system structure ensured")
            return True
        except Exception as e:
            logger.error(f"âŒ Failed to ensure managed system structure: {str(e)}")
            return False
    
    def _create_directory_structure(self):
        """Create the complete directory structure for the managed system."""
        directories = [
            "app",
            "app/models",
            "app/routes", 
            "app/database",
            "ui",
            "ui/pages",
            "ui/components",
            "tests"
        ]
        
        for directory in directories:
            (self.managed_system_path / directory).mkdir(parents=True, exist_ok=True)
            
            # Create __init__.py files for Python packages
            if directory.startswith(("app", "ui")) and "/" in directory:
                init_file = self.managed_system_path / directory / "__init__.py"
                if not init_file.exists():
                    init_file.write_text("# Auto-generated by BAE Managed System Manager\n")
    
    def _create_base_files(self):
        """Create base configuration files for the managed system."""
        # requirements.txt
        requirements_content = """# Managed System Runtime Dependencies
# Auto-generated by BAE Framework

fastapi==0.104.1
uvicorn==0.24.0
streamlit==1.28.1
pydantic==2.5.0
sqlalchemy==2.0.23
python-multipart==0.0.6
requests==2.31.0
python-dotenv==1.0.0
"""
        self._write_file("requirements.txt", requirements_content)
        
        # .env file
        env_content = f"""# Managed System Configuration
# Auto-generated by BAE Framework

API_HOST=0.0.0.0
API_PORT={Config.API_PORT}
UI_HOST=0.0.0.0
UI_PORT={Config.UI_PORT}
DATABASE_URL=sqlite:///app/database/academic.db
"""
        self._write_file(".env", env_content)
        
        # .gitignore
        gitignore_content = """# Managed System .gitignore
# Auto-generated by BAE Framework

__pycache__/
*.py[cod]
*$py.class
*.so
.Python
venv/
.env
*.db
*.sqlite
*.sqlite3
.streamlit/
"""
        self._write_file(".gitignore", gitignore_content)
        
        # README.md
        readme_content = """# BAE Managed System

This is an auto-generated academic management system created by the BAE (Business Autonomous Entity) framework.

## System Overview

This system contains all entities generated by BAE agents:
- **Domain Models**: Pydantic models representing business entities
- **API Routes**: FastAPI endpoints for CRUD operations
- **User Interface**: Streamlit web interface for entity management
- **Database**: SQLite database with entity tables

## Running the System

### Setup Virtual Environment
```bash
./setup_venv.sh
```

### Start Both Servers
```bash
./start_servers.sh
```

### Individual Server Startup
```bash
# Start FastAPI server
source venv/bin/activate
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload

# Start Streamlit UI (in another terminal)
source venv/bin/activate
streamlit run ui/app.py --server.port 8501
```

## Generated by BAE Framework

This system is automatically maintained by the BAE framework. 
Manual modifications may be overwritten during BAE regeneration cycles.
"""
        self._write_file("README.md", readme_content)
        
        # Setup virtual environment script
        setup_script = """#!/bin/bash
# Auto-generated virtual environment setup script

echo "ðŸ”§ Setting up virtual environment for Managed System..."

# Create virtual environment
python3 -m venv venv

# Activate virtual environment
source venv/bin/activate

# Upgrade pip
pip install --upgrade pip

# Install dependencies
pip install -r requirements.txt

echo "âœ… Virtual environment setup complete!"
echo "To activate: source venv/bin/activate"
"""
        self._write_file("setup_venv.sh", setup_script)
        os.chmod(self.managed_system_path / "setup_venv.sh", 0o755)
        
        # Start servers script
        start_script = """#!/bin/bash
# Auto-generated server startup script

echo "ðŸš€ Starting BAE Managed System servers..."

# Activate virtual environment
source venv/bin/activate

# Start FastAPI server in background
echo "Starting FastAPI server at http://0.0.0.0:8000"
uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload &
API_PID=$!

# Wait a moment for API to start
sleep 2

# Start Streamlit UI
echo "Starting Streamlit UI at http://0.0.0.0:8501"
streamlit run ui/app.py --server.port 8501 &
UI_PID=$!

echo "âœ… Both servers started!"
echo "API PID: $API_PID"
echo "UI PID: $UI_PID"

# Keep script running to maintain processes
wait
"""
        self._write_file("start_servers.sh", start_script)
        os.chmod(self.managed_system_path / "start_servers.sh", 0o755)
    
    def _ensure_virtual_environment(self):
        """Ensure virtual environment exists."""
        venv_path = self.managed_system_path / "venv"
        if not venv_path.exists():
            logger.info("ðŸ”§ Creating virtual environment...")
            try:
                subprocess.run([
                    sys.executable, "-m", "venv", str(venv_path)
                ], check=True, cwd=self.managed_system_path)
                logger.info("âœ… Virtual environment created")
            except subprocess.CalledProcessError as e:
                logger.error(f"âŒ Failed to create virtual environment: {e}")
    
    def _install_dependencies(self):
        """Install dependencies in the managed system virtual environment."""
        venv_path = self.managed_system_path / "venv"
        pip_path = venv_path / ("Scripts" if os.name == "nt" else "bin") / "pip"
        requirements_path = self.managed_system_path / "requirements.txt"
        
        if pip_path.exists() and requirements_path.exists():
            try:
                logger.info("ðŸ“¦ Installing managed system dependencies...")
                subprocess.run([
                    str(pip_path), "install", "-r", str(requirements_path)
                ], check=True, cwd=self.managed_system_path)
                logger.info("âœ… Dependencies installed")
            except subprocess.CalledProcessError as e:
                logger.warning(f"âš ï¸  Failed to install dependencies: {e}")
    
    def write_entity_artifact(self, entity_name: str, artifact_type: str, content: str) -> str:
        """Write an entity artifact to the managed system."""
        entity_name_lower = entity_name.lower()
        
        if artifact_type == "model":
            file_path = self.managed_system_path / "app" / "models" / f"{entity_name_lower}_model.py"
        elif artifact_type == "routes":
            file_path = self.managed_system_path / "app" / "routes" / f"{entity_name_lower}_routes.py"
        elif artifact_type == "ui":
            file_path = self.managed_system_path / "ui" / "pages" / f"{entity_name_lower}_management.py"
        elif artifact_type == "tests":
            file_path = self.managed_system_path / "tests" / f"test_{entity_name_lower}_api.py"
        else:
            raise ValueError(f"Unknown artifact type: {artifact_type}")
        
        # Ensure parent directory exists
        file_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Write content
        file_path.write_text(content, encoding="utf-8")
        
        logger.info(f"âœ… Written {artifact_type} for {entity_name} to {file_path}")
        return str(file_path)
    
    def _write_file(self, relative_path: str, content: str):
        """Write content to a file in the managed system."""
        file_path = self.managed_system_path / relative_path
        file_path.parent.mkdir(parents=True, exist_ok=True)
        file_path.write_text(content, encoding="utf-8")
    
    def get_managed_system_info(self) -> Dict[str, Any]:
        """Get information about the managed system."""
        entities = []
        
        # Check for models
        models_path = self.managed_system_path / "app" / "models"
        if models_path.exists():
            for model_file in models_path.glob("*_model.py"):
                entity_name = model_file.stem.replace("_model", "")
                entities.append(entity_name)
        
        return {
            "path": str(self.managed_system_path),
            "exists": self.managed_system_path.exists(),
            "entities": entities,
            "structure_complete": self._check_structure_complete()
        }
    
    def create_main_app_file(self):
        """Create the main FastAPI application file."""
        main_app_content = '''"""
Main FastAPI application for BAE Managed System.
Auto-generated by BAE Framework - contains all entity routes.
"""

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import importlib
import logging
from pathlib import Path

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create FastAPI app
app = FastAPI(
    title="BAE Managed Academic System",
    description="Auto-generated academic management system with multiple entities",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def root():
    """Root endpoint with system information."""
    return {
        "message": "BAE Managed Academic System",
        "description": "Auto-generated system managing multiple business entities",
        "version": "1.0.0",
        "entities": get_available_entities(),
        "docs": "/docs"
    }

@app.get("/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "healthy", "system": "BAE Managed System"}

def get_available_entities():
    """Get list of available entities based on generated routes."""
    entities = []
    routes_path = Path(__file__).parent / "routes"
    
    if routes_path.exists():
        for route_file in routes_path.glob("*_routes.py"):
            entity_name = route_file.stem.replace("_routes", "")
            entities.append(entity_name)
    
    return entities

def load_all_routes():
    """Dynamically load all available entity routes."""
    routes_path = Path(__file__).parent / "routes"
    
    if not routes_path.exists():
        logger.warning("Routes directory not found")
        return
    
    for route_file in routes_path.glob("*_routes.py"):
        try:
            module_name = f"app.routes.{route_file.stem}"
            module = importlib.import_module(module_name)
            
            if hasattr(module, "router"):
                app.include_router(module.router)
                logger.info(f"âœ… Loaded routes from {module_name}")
            else:
                logger.warning(f"âš ï¸  No router found in {module_name}")
                
        except Exception as e:
            logger.error(f"âŒ Failed to load {route_file}: {str(e)}")

# Load all available routes
load_all_routes()

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)
'''
        self._write_file("app/main.py", main_app_content)
        self._write_file("app/__init__.py", "# BAE Managed System App Package\n")
    
    def create_main_ui_file(self):
        """Create the main Streamlit UI file."""
        main_ui_content = '''"""
Main Streamlit UI for BAE Managed System.
Auto-generated by BAE Framework - provides navigation to all entity management pages.
"""

import streamlit as st
import importlib
import sys
from pathlib import Path

# Configure page
st.set_page_config(
    page_title="BAE Academic Management System",
    page_icon="ðŸŽ“",
    layout="wide",
    initial_sidebar_state="expanded"
)

def main():
    """Main Streamlit application."""
    st.title("ðŸŽ“ BAE Academic Management System")
    st.markdown("**Auto-generated system for managing multiple business entities**")
    
    # Sidebar navigation
    st.sidebar.title("ðŸ“‹ Entity Management")
    st.sidebar.markdown("Select an entity to manage:")
    
    # Get available entities
    available_entities = get_available_entities()
    
    if not available_entities:
        st.warning("âš ï¸ No entities have been generated yet. Use the BAE framework to generate your first entity.")
        st.info("Example: Run the BAE system with a request like 'Create a system to manage students'")
        return
    
    # Entity selection
    selected_entity = st.sidebar.selectbox(
        "Choose Entity:",
        available_entities,
        format_func=lambda x: x.replace("_", " ").title()
    )
    
    # Load and display entity management page
    if selected_entity:
        load_entity_page(selected_entity)
    
    # System information in sidebar
    st.sidebar.markdown("---")
    st.sidebar.markdown("### ðŸ¤– System Information")
    st.sidebar.info(f"**Entities**: {len(available_entities)}")
    st.sidebar.info("**Generated by**: BAE Framework")

def get_available_entities():
    """Get list of available entities based on generated pages."""
    entities = []
    pages_path = Path(__file__).parent / "pages"
    
    if pages_path.exists():
        for page_file in pages_path.glob("*_management.py"):
            entity_name = page_file.stem.replace("_management", "")
            entities.append(entity_name)
    
    return entities

def load_entity_page(entity_name):
    """Dynamically load entity management page."""
    try:
        # Add pages directory to Python path
        pages_path = Path(__file__).parent / "pages"
        if str(pages_path) not in sys.path:
            sys.path.insert(0, str(pages_path))
        
        module_name = f"{entity_name}_management"
        
        # Import the entity management module
        if module_name in sys.modules:
            # Reload if already imported (for hot reload)
            importlib.reload(sys.modules[module_name])
            module = sys.modules[module_name]
        else:
            module = importlib.import_module(module_name)
        
        # Call the main function if it exists
        if hasattr(module, "main"):
            module.main()
        elif hasattr(module, "show_entity_management"):
            module.show_entity_management()
        else:
            st.error(f"âŒ No main() or show_entity_management() function found in {module_name}")
            
    except Exception as e:
        st.error(f"âŒ Failed to load {entity_name} management page: {str(e)}")
        st.info("This usually means the entity page hasn't been generated yet.")

if __name__ == "__main__":
    main()
'''
        self._write_file("ui/app.py", main_ui_content)
        self._write_file("ui/__init__.py", "# BAE Managed System UI Package\n")
    
    def create_database_connection_file(self):
        """Create database connection configuration."""
        db_connection_content = '''"""
Database connection configuration for BAE Managed System.
Auto-generated by BAE Framework.
"""

import os
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from pathlib import Path

# Database configuration
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///app/database/academic.db")

# Ensure database directory exists
db_path = Path(__file__).parent / "academic.db"
db_path.parent.mkdir(parents=True, exist_ok=True)

# Create SQLAlchemy engine
engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False} if "sqlite" in DATABASE_URL else {}
)

# Create SessionLocal class
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Create Base class for models
Base = declarative_base()

def get_db():
    """Get database session."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def create_all_tables():
    """Create all tables in the database."""
    Base.metadata.create_all(bind=engine)
'''
        self._write_file("app/database/connection.py", db_connection_content)
        self._write_file("app/database/__init__.py", "# BAE Managed System Database Package\n")
    
    def update_system_files(self):
        """Update main system files to reflect current entities."""
        self.create_main_app_file()
        self.create_main_ui_file()
        self.create_database_connection_file()
    
    def _check_structure_complete(self) -> bool:
        """Check if the managed system structure is complete."""
        required_paths = [
            "app/main.py",
            "ui/app.py", 
            "app/database/connection.py",
            "requirements.txt",
            "README.md"
        ]
        
        return all(
            (self.managed_system_path / path).exists() 
            for path in required_paths
        ) 