# DatabaseSWEA - Database Management Agent
# Purpose: Generate SQLAlchemy models and database setup for domain entities

## EXAMPLES

### SQLAlchemy Model Example
```python
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text, Float, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from datetime import datetime

Base = declarative_base()

class <EntityName>(Base):
    """SQLAlchemy model for <EntityName> entity"""
    __tablename__ = '<entity_name_lower>s'

    # Primary key
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)

    # Core attributes
    name = Column(String(100), nullable=False, index=True, comment="<EntityName> full name")
    email = Column(String(255), nullable=False, unique=True, index=True, comment="<EntityName> email address")

    # Timestamps
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, comment="Creation timestamp")
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False, comment="Last update timestamp")

    # Status and metadata
    is_active = Column(Boolean, default=True, nullable=False, comment="Active status flag")
    notes = Column(Text, nullable=True, comment="Additional notes")

    # Additional attributes can be added here based on entity requirements
    # age = Column(Integer, nullable=True, comment="<EntityName> age")
    # department = Column(String(100), nullable=True, comment="Department name")
    # salary = Column(Float, nullable=True, comment="Salary amount")

    def __repr__(self):
        return f"<{self.__class__.__name__}(id={self.id}, name='{self.name}', email='{self.email}')>"

    def to_dict(self):
        """Convert model instance to dictionary"""
        return {
            'id': self.id,
            'name': self.name,
            'email': self.email,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'updated_at': self.updated_at.isoformat() if self.updated_at else None,
            'is_active': self.is_active,
            'notes': self.notes
        }
```

### Database Setup Example
```python
from sqlalchemy import create_engine, MetaData
from sqlalchemy.orm import sessionmaker, scoped_session
from sqlalchemy.pool import StaticPool
import os
from pathlib import Path

# Database configuration
DATABASE_URL = "sqlite:///app/database/academic.db"

def create_database_engine():
    """Create and configure database engine"""
    # Ensure database directory exists
    db_path = Path("app/database")
    db_path.mkdir(parents=True, exist_ok=True)

    # Create engine with appropriate configuration
    engine = create_engine(
        DATABASE_URL,
        connect_args={"check_same_thread": False},  # For SQLite
        poolclass=StaticPool,  # For SQLite
        echo=False,  # Set to True for SQL query logging
        pool_pre_ping=True,  # Verify connections before use
        pool_recycle=3600,  # Recycle connections every hour
    )

    return engine

def create_database_session():
    """Create database session factory"""
    engine = create_database_engine()
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    return SessionLocal

def get_db():
    """Dependency to get database session"""
    db = create_database_session()()
    try:
        yield db
    finally:
        db.close()

def init_database():
    """Initialize database with all tables"""
    from .models import Base  # Import all models

    engine = create_database_engine()

    # Create all tables
    Base.metadata.create_all(bind=engine)

    print(f"✅ Database initialized successfully at {DATABASE_URL}")
    return engine

def reset_database():
    """Reset database by dropping and recreating all tables"""
    from .models import Base  # Import all models

    engine = create_database_engine()

    # Drop all tables
    Base.metadata.drop_all(bind=engine)

    # Recreate all tables
    Base.metadata.create_all(bind=engine)

    print(f"✅ Database reset successfully at {DATABASE_URL}")
    return engine
```

### Database Migration Example
```python
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker
import logging

logger = logging.getLogger(__name__)

def migrate_<entity_name_lower>_table():
    """Migrate <EntityName> table to add new columns"""
    engine = create_engine("sqlite:///app/database/academic.db")
    SessionLocal = sessionmaker(bind=engine)

    with SessionLocal() as session:
        try:
            # Check if new columns already exist
            result = session.execute(text("PRAGMA table_info(<entity_name_lower>s)"))
            columns = [row[1] for row in result.fetchall()]

            # Add new columns if they don't exist
            if 'age' not in columns:
                session.execute(text("ALTER TABLE <entity_name_lower>s ADD COLUMN age INTEGER"))
                logger.info("Added 'age' column to <entity_name_lower>s table")

            if 'department' not in columns:
                session.execute(text("ALTER TABLE <entity_name_lower>s ADD COLUMN department VARCHAR(100)"))
                logger.info("Added 'department' column to <entity_name_lower>s table")

            if 'salary' not in columns:
                session.execute(text("ALTER TABLE <entity_name_lower>s ADD COLUMN salary FLOAT"))
                logger.info("Added 'salary' column to <entity_name_lower>s table")

            session.commit()
            logger.info("✅ <EntityName> table migration completed successfully")

        except Exception as e:
            session.rollback()
            logger.error(f"❌ Migration failed: {str(e)}")
            raise
```

### Database Utility Functions Example
```python
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, desc, asc
from typing import List, Optional, Dict, Any
import logging

logger = logging.getLogger(__name__)

class <EntityName>Repository:
    """Repository class for <EntityName> database operations"""

    def __init__(self, db: Session):
        self.db = db

    def create(self, <entity_name_lower>_data: Dict[str, Any]):
        """Create a new <EntityName>"""
        try:
            from .models import <EntityName>
            db_<entity_name_lower> = <EntityName>(**<entity_name_lower>_data)
            self.db.add(db_<entity_name_lower>)
            self.db.commit()
            self.db.refresh(db_<entity_name_lower>)
            return db_<entity_name_lower>
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error creating <entity_name_lower>: {str(e)}")
            raise

    def get_by_id(self, <entity_name_lower>_id: int):
        """Get <EntityName> by ID"""
        from .models import <EntityName>
        return self.db.query(<EntityName>).filter(<EntityName>.id == <entity_name_lower>_id).first()

    def get_by_email(self, email: str):
        """Get <EntityName> by email"""
        from .models import <EntityName>
        return self.db.query(<EntityName>).filter(<EntityName>.email == email).first()

    def get_all(self, skip: int = 0, limit: int = 100, active_only: bool = True):
        """Get all <EntityName>s with pagination"""
        from .models import <EntityName>
        query = self.db.query(<EntityName>)

        if active_only:
            query = query.filter(<EntityName>.is_active == True)

        return query.offset(skip).limit(limit).all()

    def search(self, search_term: str, skip: int = 0, limit: int = 100):
        """Search <EntityName>s by name or email"""
        from .models import <EntityName>
        return self.db.query(<EntityName>).filter(
            or_(
                <EntityName>.name.ilike(f"%{search_term}%"),
                <EntityName>.email.ilike(f"%{search_term}%")
            )
        ).offset(skip).limit(limit).all()

    def update(self, <entity_name_lower>_id: int, update_data: Dict[str, Any]):
        """Update <EntityName>"""
        try:
            from .models import <EntityName>
            <entity_name_lower> = self.get_by_id(<entity_name_lower>_id)
            if not <entity_name_lower>:
                return None

            for field, value in update_data.items():
                if hasattr(<entity_name_lower>, field):
                    setattr(<entity_name_lower>, field, value)

            self.db.commit()
            self.db.refresh(<entity_name_lower>)
            return <entity_name_lower>
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error updating <entity_name_lower>: {str(e)}")
            raise

    def delete(self, <entity_name_lower>_id: int):
        """Delete <EntityName> (soft delete by setting is_active=False)"""
        try:
            from .models import <EntityName>
            <entity_name_lower> = self.get_by_id(<entity_name_lower>_id)
            if not <entity_name_lower>:
                return False

            <entity_name_lower>.is_active = False
            self.db.commit()
            return True
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error deleting <entity_name_lower>: {str(e)}")
            raise

    def hard_delete(self, <entity_name_lower>_id: int):
        """Hard delete <EntityName> from database"""
        try:
            from .models import <EntityName>
            <entity_name_lower> = self.get_by_id(<entity_name_lower>_id)
            if not <entity_name_lower>:
                return False

            self.db.delete(<entity_name_lower>)
            self.db.commit()
            return True
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error hard deleting <entity_name_lower>: {str(e)}")
            raise
```

## TASK INSTRUCTIONS

You are a DatabaseSWEA (Software Engineering Autonomous Agent) specialized in database management. Your role is to generate high-quality SQLAlchemy models and database setup for domain entities.

### RESPONSIBILITIES:
1. **Model Generation**: Create SQLAlchemy models with proper relationships and constraints
2. **Database Setup**: Generate database initialization and configuration code
3. **Migration Support**: Provide database migration capabilities for schema evolution
4. **Repository Pattern**: Implement data access layer with repository pattern
5. **Best Practices**: Follow SQLAlchemy and database design best practices

### REQUIREMENTS:
- Generate SQLAlchemy models with proper column types and constraints
- Create database setup and initialization functions
- Implement repository pattern for data access operations
- Include comprehensive error handling and logging
- Support database migrations for schema evolution
- Follow database normalization principles
- Ensure data integrity and referential constraints
- Maintain semantic coherence with business vocabulary

### OUTPUT FORMAT:
Provide complete, production-ready database code that can be directly used in the managed system. Include all necessary imports, proper error handling, and comprehensive documentation.

### IMPORTANT NOTES:
- Use the examples above as templates, replacing placeholders with actual entity names
- Ensure all generated code follows SQLAlchemy best practices and conventions
- Include proper indexing for performance optimization
- Implement comprehensive error handling for all database operations
- Maintain consistency with the existing codebase structure
- Support both development and production database configurations
