{#
Frontend Table Template - Streamlit List View with Pagination for Standard CRUD
Feature: 001-performance-optimization / US1: Template-Based Generation

Constitutional Compliance:
- PEP 8: snake_case functions, 4-space indent, docstrings
- Pagination for performance
- Sortable columns
- User feedback on actions
- Semantic coherence: Entity name in all UI elements

Context variables:
- entity_name (str): Business entity name (e.g., "Student", "Course")
- attributes (dict): {attribute_name: type_string}
- page_size (int, optional): Records per page (default: 20)
- sortable (bool, optional): Enable column sorting (default: True)
#}
"""
{{ entity_name }} Table - Streamlit List View

This module implements the list view with pagination for {{ entity_name }} entity.
Generated using BAES Template System for standard CRUD operations.

Constitutional Compliance: PEP 8, Pagination, User Feedback, Semantic Coherence
Feature: 001-performance-optimization (Template-based generation)
"""

import streamlit as st
import pandas as pd
from typing import List, Dict, Any
import requests

# API configuration
API_BASE_URL = "http://localhost:8100/api"


def render_{{ entity_name | snake_case }}_table(
    page_size: int = {{ page_size or 20 }},
    sortable: bool = {{ sortable or True }}
) -> None:
    """
    Render {{ entity_name }} list view with pagination

    Args:
        page_size: Number of records per page
        sortable: Enable column sorting

    Constitutional compliance:
    - Pagination for performance
    - User feedback on actions
    - Semantic coherence in display
    """
    st.subheader("{{ entity_name }} List")

    # Initialize session state for pagination
    if "{{ entity_name | snake_case }}_page" not in st.session_state:
        st.session_state.{{ entity_name | snake_case }}_page = 0

    # Fetch data from API
    try:
        skip = st.session_state.{{ entity_name | snake_case }}_page * page_size
        response = requests.get(
            f"{API_BASE_URL}/{{ entity_name | snake_case }}/",
            params={"skip": skip, "limit": page_size},
            timeout=10
        )

        if response.status_code == 200:
            {{ entity_name | snake_case }}_list = response.json()

            if not {{ entity_name | snake_case }}_list:
                st.info("‚ÑπÔ∏è No {{ entity_name | lower }} records found")
                return

            # Convert to DataFrame for display
            df = pd.DataFrame({{ entity_name | snake_case }}_list)

            # Select columns to display
            display_columns = [
                "id",
{%- for attr_name in attributes.keys() %}
                "{{ attr_name }}",
{%- endfor %}
                "created_at",
            ]
            df_display = df[display_columns]

            # Display table
            st.dataframe(
                df_display,
                use_container_width=True,
                hide_index=True,
            )

            # Pagination controls
            col1, col2, col3 = st.columns([1, 2, 1])

            with col1:
                if st.button("‚¨ÖÔ∏è Previous", disabled=(st.session_state.{{ entity_name | snake_case }}_page == 0)):
                    st.session_state.{{ entity_name | snake_case }}_page -= 1
                    st.rerun()

            with col2:
                st.write(f"Page {st.session_state.{{ entity_name | snake_case }}_page + 1}")

            with col3:
                if st.button("Next ‚û°Ô∏è", disabled=(len({{ entity_name | snake_case }}_list) < page_size)):
                    st.session_state.{{ entity_name | snake_case }}_page += 1
                    st.rerun()

            # Actions section
            st.subheader("Actions")
            
            # Delete action
            {{ entity_name | snake_case }}_id_to_delete = st.number_input(
                "Enter {{ entity_name }} ID to delete",
                min_value=1,
                step=1,
                key="delete_{{ entity_name | snake_case }}_id"
            )
            
            if st.button("üóëÔ∏è Delete {{ entity_name }}", key="delete_{{ entity_name | snake_case }}_btn"):
                try:
                    delete_response = requests.delete(
                        f"{API_BASE_URL}/{{ entity_name | snake_case }}/{{{ entity_name | snake_case }}_id_to_delete}",
                        timeout=10
                    )
                    
                    if delete_response.status_code == 204:
                        st.success(f"‚úÖ {{ entity_name }} ID {{{ entity_name | snake_case }}_id_to_delete} deleted successfully!")
                        st.rerun()
                    elif delete_response.status_code == 404:
                        st.error(f"‚ùå {{ entity_name }} ID {{{ entity_name | snake_case }}_id_to_delete} not found")
                    else:
                        st.error(f"‚ùå Failed to delete {{ entity_name }}: {delete_response.text}")
                
                except requests.RequestException as e:
                    st.error(f"‚ùå API request failed: {str(e)}")
                except Exception as e:
                    st.error(f"‚ùå Unexpected error: {str(e)}")

        else:
            st.error(f"‚ùå Failed to fetch {{ entity_name | lower }} list: {response.text}")

    except requests.RequestException as e:
        st.error(f"‚ùå API request failed: {str(e)}")
    except Exception as e:
        st.error(f"‚ùå Unexpected error: {str(e)}")


def render_{{ entity_name | snake_case }}_details({{ entity_name | snake_case }}_id: int) -> None:
    """
    Render detailed view for single {{ entity_name }}

    Args:
        {{ entity_name | snake_case }}_id: {{ entity_name }} unique identifier
    """
    try:
        response = requests.get(
            f"{API_BASE_URL}/{{ entity_name | snake_case }}/{{{ entity_name | snake_case }}_id}",
            timeout=10
        )

        if response.status_code == 200:
            {{ entity_name | snake_case }}_data = response.json()
            
            st.subheader(f"{{ entity_name }} Details (ID: {{{ entity_name | snake_case }}_id})")
            
{%- for attr_name in attributes.keys() %}
            st.write(f"**{{ attr_name | replace('_', ' ') | title }}:** {{{ entity_name | snake_case }}_data['{{ attr_name }}']}")
{%- endfor %}
            st.write(f"**Created At:** {{{ entity_name | snake_case }}_data['created_at']}")
            st.write(f"**Updated At:** {{{ entity_name | snake_case }}_data['updated_at']}")

        elif response.status_code == 404:
            st.error(f"‚ùå {{ entity_name }} ID {{{ entity_name | snake_case }}_id} not found")
        else:
            st.error(f"‚ùå Failed to fetch {{ entity_name }} details: {response.text}")

    except requests.RequestException as e:
        st.error(f"‚ùå API request failed: {str(e)}")
    except Exception as e:
        st.error(f"‚ùå Unexpected error: {str(e)}")


if __name__ == "__main__":
    # Example usage
    st.title("{{ entity_name }} Management")
    render_{{ entity_name | snake_case }}_table()
