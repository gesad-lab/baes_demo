{
  "timestamp": "2025-06-30T15:34:58.043134",
  "request_id": "BackendSWEA_Student_generate_api_code_2025-06-30T15-34-17.747057",
  "response_text": "from fastapi import APIRouter, HTTPException, Depends, status\nfrom sqlalchemy.orm import Session\nfrom typing import List, Optional\nfrom pydantic import BaseModel, Field, validator\nfrom datetime import datetime\nimport sqlite3\n\n# Pydantic Models (Request/Response schemas)\nclass StudentBase(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100, description=\"Student name\")\n    email: str = Field(..., description=\"Student email address\")\n    age: int = Field(..., ge=0, description=\"Student age\")\n    created_at: datetime = Field(default_factory=datetime.now, description=\"Creation timestamp\")\n    updated_at: datetime = Field(default_factory=datetime.now, description=\"Last update timestamp\")\n\n    @validator('email')\n    def validate_email(cls, v):\n        if not re.match(r\"[^@]+@[^@]+\\.[^@]+\", v):\n            raise ValueError('Invalid email format')\n        return v.lower()\n\nclass StudentCreate(StudentBase):\n    pass\n\nclass StudentUpdate(BaseModel):\n    name: Optional[str] = Field(None, min_length=1, max_length=100)\n    email: Optional[str] = Field(None)\n    age: Optional[int] = Field(None, ge=0)\n\n    @validator('email')\n    def validate_email(cls, v):\n        if v is not None and not re.match(r\"[^@]+@[^@]+\\.[^@]+\", v):\n            raise ValueError('Invalid email format')\n        return v.lower() if v else v\n\nclass StudentResponse(StudentBase):\n    id: int\n\n    class Config:\n        orm_mode = True\n\n# Database Operations\nclass StudentDB:\n    def __init__(self, db_path: str):\n        self.db_path = db_path\n        self._init_db()\n\n    def _init_db(self):\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                cursor = conn.cursor()\n                cursor.execute('''\n                    CREATE TABLE IF NOT EXISTS students (\n                        id INTEGER PRIMARY KEY AUTOINCREMENT,\n                        name TEXT NOT NULL,\n                        email TEXT NOT NULL UNIQUE,\n                        age INTEGER NOT NULL,\n                        created_at TEXT NOT NULL,\n                        updated_at TEXT NOT NULL\n                    )\n                ''')\n                conn.commit()\n        except sqlite3.Error as e:\n            raise HTTPException(status_code=500, detail=f\"Database initialization error: {str(e)}\")\n\n    def create(self, student: StudentCreate) -> StudentResponse:\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                cursor = conn.cursor()\n                cursor.execute('''\n                    INSERT INTO students (name, email, age, created_at, updated_at)\n                    VALUES (?, ?, ?, ?, ?)\n                ''', (student.name, student.email, student.age, student.created_at.isoformat(), student.updated_at.isoformat()))\n                conn.commit()\n                student_id = cursor.lastrowid\n                return StudentResponse(id=student_id, **student.dict())\n        except sqlite3.IntegrityError:\n            raise HTTPException(status_code=400, detail=f\"Student with email {student.email} already exists\")\n        except sqlite3.Error as e:\n            raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n    def get_all(self) -> List[StudentResponse]:\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                cursor = conn.cursor()\n                cursor.execute('SELECT * FROM students')\n                rows = cursor.fetchall()\n                return [StudentResponse(id=row[0], name=row[1], email=row[2], age=row[3], created_at=row[4], updated_at=row[5]) for row in rows]\n        except sqlite3.Error as e:\n            raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n    def get_by_id(self, student_id: int) -> Optional[StudentResponse]:\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                cursor = conn.cursor()\n                cursor.execute('SELECT * FROM students WHERE id = ?', (student_id,))\n                row = cursor.fetchone()\n                if row:\n                    return StudentResponse(id=row[0], name=row[1], email=row[2], age=row[3], created_at=row[4], updated_at=row[5])\n                return None\n        except sqlite3.Error as e:\n            raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n    def update(self, student_id: int, student_data: StudentUpdate) -> Optional[StudentResponse]:\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                cursor = conn.cursor()\n                cursor.execute('SELECT * FROM students WHERE id = ?', (student_id,))\n                row = cursor.fetchone()\n                if not row:\n                    return None\n\n                updated_name = student_data.name if student_data.name is not None else row[1]\n                updated_email = student_data.email if student_data.email is not None else row[2]\n                updated_age = student_data.age if student_data.age is not None else row[3]\n                updated_at = datetime.now().isoformat()\n\n                cursor.execute('''\n                    UPDATE students\n                    SET name = ?, email = ?, age = ?, updated_at = ?\n                    WHERE id = ?\n                ''', (updated_name, updated_email, updated_age, updated_at, student_id))\n                conn.commit()\n                return StudentResponse(id=student_id, name=updated_name, email=updated_email, age=updated_age, created_at=row[4], updated_at=updated_at)\n        except sqlite3.IntegrityError:\n            raise HTTPException(status_code=400, detail=f\"Student with email {student_data.email} already exists\")\n        except sqlite3.Error as e:\n            raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n    def delete(self, student_id: int) -> bool:\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                cursor = conn.cursor()\n                cursor.execute('SELECT * FROM students WHERE id = ?', (student_id,))\n                row = cursor.fetchone()\n                if not row:\n                    return False\n\n                cursor.execute('DELETE FROM students WHERE id = ?', (student_id,))\n                conn.commit()\n                return True\n        except sqlite3.Error as e:\n            raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n\n# FastAPI Router\nrouter = APIRouter(prefix=\"/api/students\", tags=[\"students\"])\n\n# Database dependency\ndef get_db():\n    db_path = \"app/database/academic.db\"\n    return StudentDB(db_path)\n\n# CRUD Endpoints\n@router.post(\"/\", response_model=StudentResponse, status_code=status.HTTP_201_CREATED)\ndef create_student(student: StudentCreate, db: StudentDB = Depends(get_db)):\n    return db.create(student)\n\n@router.get(\"/\", response_model=List[StudentResponse])\ndef get_students(db: StudentDB = Depends(get_db)):\n    return db.get_all()\n\n@router.get(\"/{student_id}\", response_model=StudentResponse)\ndef get_student(student_id: int, db: StudentDB = Depends(get_db)):\n    student = db.get_by_id(student_id)\n    if not student:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Student with ID {student_id} not found\")\n    return student\n\n@router.put(\"/{student_id}\", response_model=StudentResponse)\ndef update_student(student_id: int, student: StudentUpdate, db: StudentDB = Depends(get_db)):\n    updated_student = db.update(student_id, student)\n    if not updated_student:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Student with ID {student_id} not found\")\n    return updated_student\n\n@router.delete(\"/{student_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_student(student_id: int, db: StudentDB = Depends(get_db)):\n    if not db.delete(student_id):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=f\"Student with ID {student_id} not found\")",
  "success": true,
  "error_message": null,
  "response_time_ms": 0.0,
  "token_count": null,
  "model_used": "gpt-4o-mini"
}