{
  "timestamp": "2025-06-30T15:39:32.018694",
  "request_id": "BackendSWEA_Student_generate_api_code_2025-06-30T15-39-13.237253",
  "response_text": "from fastapi import APIRouter, HTTPException, Depends, status, Response\nfrom pydantic import BaseModel\nfrom typing import List, Optional\nimport sqlite3\nfrom pathlib import Path\nfrom contextlib import contextmanager\nimport logging\nfrom datetime import datetime\n\nlogger = logging.getLogger(__name__)\n\n@contextmanager\ndef get_db_connection():\n    db_path = Path(\"../database/academic.db\")\n    if not db_path.exists():\n        raise HTTPException(status_code=500, detail=f\"Database not found at {db_path}\")\n    conn = sqlite3.connect(str(db_path))\n    conn.row_factory = sqlite3.Row\n    try:\n        yield conn\n    except Exception:\n        conn.rollback()\n        raise\n    finally:\n        conn.close()\n\ndef get_db():\n    with get_db_connection() as conn:\n        yield conn\n\nclass StudentBase(BaseModel):\n    name: str\n    email: str\n    age: int\n\nclass StudentCreate(StudentBase):\n    pass\n\nclass StudentUpdate(BaseModel):\n    name: Optional[str] = None\n    email: Optional[str] = None\n    age: Optional[int] = None\n\nclass StudentResponse(StudentBase):\n    id: int\n    created_at: datetime\n    updated_at: datetime\n\n    class Config:\n        from_attributes = True\n\nrouter = APIRouter(prefix=\"/api/students\", tags=[\"Students\"])\n\n@router.post(\"/\", response_model=StudentResponse, status_code=status.HTTP_201_CREATED)\nasync def create_student(student_data: StudentCreate, db: sqlite3.Connection = Depends(get_db)) -> StudentResponse:\n    try:\n        cursor = db.cursor()\n        created_at = updated_at = datetime.utcnow()\n        cursor.execute(\n            \"INSERT INTO students (name, email, age, created_at, updated_at) VALUES (?, ?, ?, ?, ?)\",\n            (student_data.name, student_data.email, student_data.age, created_at, updated_at)\n        )\n        db.commit()\n        student_id = cursor.lastrowid\n        cursor.execute(\"SELECT * FROM students WHERE id = ?\", (student_id,))\n        row = cursor.fetchone()\n        return StudentResponse(**dict(row))\n    except Exception as e:\n        db.rollback()\n        logger.error(f\"Error creating student: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to create student\")\n\n@router.get(\"/\", response_model=List[StudentResponse])\nasync def list_students(db: sqlite3.Connection = Depends(get_db)) -> List[StudentResponse]:\n    try:\n        cursor = db.cursor()\n        cursor.execute(\"SELECT * FROM students\")\n        rows = cursor.fetchall()\n        return [StudentResponse(**dict(row)) for row in rows]\n    except Exception as e:\n        logger.error(f\"Error listing students: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to list students\")\n\n@router.get(\"/{id}\", response_model=StudentResponse)\nasync def get_student(id: int, db: sqlite3.Connection = Depends(get_db)) -> StudentResponse:\n    try:\n        cursor = db.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE id = ?\", (id,))\n        row = cursor.fetchone()\n        if not row:\n            raise HTTPException(status_code=404, detail=\"Student not found\")\n        return StudentResponse(**dict(row))\n    except Exception as e:\n        logger.error(f\"Error getting student {id}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to get student\")\n\n@router.put(\"/{id}\", response_model=StudentResponse)\nasync def update_student(id: int, student_data: StudentUpdate, db: sqlite3.Connection = Depends(get_db)) -> StudentResponse:\n    try:\n        cursor = db.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE id = ?\", (id,))\n        if not cursor.fetchone():\n            raise HTTPException(status_code=404, detail=\"Student not found\")\n        \n        fields = student_data.dict(exclude_unset=True)\n        if not fields:\n            raise HTTPException(status_code=400, detail=\"No fields to update\")\n        \n        set_clause = \", \".join([f\"{field} = ?\" for field in fields.keys()])\n        values = list(fields.values()) + [id]\n        values.append(datetime.utcnow())\n        \n        cursor.execute(f\"UPDATE students SET {set_clause}, updated_at = ? WHERE id = ?\", values)\n        db.commit()\n        \n        cursor.execute(\"SELECT * FROM students WHERE id = ?\", (id,))\n        row = cursor.fetchone()\n        return StudentResponse(**dict(row))\n    except Exception as e:\n        db.rollback()\n        logger.error(f\"Error updating student {id}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to update student\")\n\n@router.delete(\"/{id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_student(id: int, db: sqlite3.Connection = Depends(get_db)) -> Response:\n    try:\n        cursor = db.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE id = ?\", (id,))\n        if not cursor.fetchone():\n            raise HTTPException(status_code=404, detail=\"Student not found\")\n        \n        cursor.execute(\"DELETE FROM students WHERE id = ?\", (id,))\n        db.commit()\n        return Response(status_code=status.HTTP_204_NO_CONTENT)\n    except Exception as e:\n        db.rollback()\n        logger.error(f\"Error deleting student {id}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to delete student\")",
  "success": true,
  "error_message": null,
  "response_time_ms": 0.0,
  "token_count": null,
  "model_used": "gpt-4o-mini"
}