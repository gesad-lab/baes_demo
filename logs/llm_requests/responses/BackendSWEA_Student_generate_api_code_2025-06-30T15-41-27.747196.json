{
  "timestamp": "2025-06-30T15:41:50.790781",
  "request_id": "BackendSWEA_Student_generate_api_code_2025-06-30T15-41-27.747196",
  "response_text": "from fastapi import APIRouter, HTTPException, Depends, status, Response\nfrom pydantic import BaseModel\nfrom typing import List\nimport sqlite3\nfrom pathlib import Path\nfrom contextlib import contextmanager\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@contextmanager\ndef get_db_connection():\n    db_path = Path(\"../database/academic.db\")\n    if not db_path.exists():\n        raise HTTPException(status_code=500, detail=f\"Database not found at {db_path}\")\n    conn = sqlite3.connect(str(db_path))\n    conn.row_factory = sqlite3.Row\n    try:\n        yield conn\n    except Exception:\n        conn.rollback()\n        raise\n    finally:\n        conn.close()\n\ndef get_db():\n    with get_db_connection() as conn:\n        yield conn\n\nclass StudentBase(BaseModel):\n    name: str\n    registration_number: str\n    course: str\n\nclass StudentCreate(StudentBase):\n    pass\n\nclass StudentUpdate(BaseModel):\n    name: str = None\n    registration_number: str = None\n    course: str = None\n\nclass StudentResponse(StudentBase):\n    id: int\n\n    class Config:\n        from_attributes = True\n\nrouter = APIRouter(prefix=\"/api/students\", tags=[\"Students\"])\n\n@router.post(\"/\", response_model=StudentResponse, status_code=status.HTTP_201_CREATED)\nasync def create_student(student_data: StudentCreate, db: sqlite3.Connection = Depends(get_db)) -> StudentResponse:\n    \"\"\"Create a new student.\"\"\"\n    try:\n        cursor = db.cursor()\n        cursor.execute(\"INSERT INTO students (name, registration_number, course) VALUES (?, ?, ?)\",\n                       (student_data.name, student_data.registration_number, student_data.course))\n        db.commit()\n        student_id = cursor.lastrowid\n        cursor.execute(\"SELECT * FROM students WHERE id = ?\", (student_id,))\n        row = cursor.fetchone()\n        return StudentResponse(id=student_id, **dict(row))\n    except Exception as e:\n        db.rollback()\n        logger.error(f\"Error creating student: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to create student\")\n\n@router.get(\"/\", response_model=List[StudentResponse])\nasync def list_students(db: sqlite3.Connection = Depends(get_db)) -> List[StudentResponse]:\n    \"\"\"List all students.\"\"\"\n    try:\n        cursor = db.cursor()\n        cursor.execute(\"SELECT * FROM students\")\n        rows = cursor.fetchall()\n        return [StudentResponse(id=row[\"id\"], name=row[\"name\"], registration_number=row[\"registration_number\"], course=row[\"course\"]) for row in rows]\n    except Exception as e:\n        logger.error(f\"Error listing students: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to list students\")\n\n@router.get(\"/{id}\", response_model=StudentResponse)\nasync def get_student(id: int, db: sqlite3.Connection = Depends(get_db)) -> StudentResponse:\n    \"\"\"Get a student by ID.\"\"\"\n    try:\n        cursor = db.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE id = ?\", (id,))\n        row = cursor.fetchone()\n        if not row:\n            raise HTTPException(status_code=404, detail=\"Student not found\")\n        return StudentResponse(id=row[\"id\"], name=row[\"name\"], registration_number=row[\"registration_number\"], course=row[\"course\"])\n    except Exception as e:\n        logger.error(f\"Error getting student {id}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to get student\")\n\n@router.put(\"/{id}\", response_model=StudentResponse)\nasync def update_student(id: int, student_data: StudentUpdate, db: sqlite3.Connection = Depends(get_db)) -> StudentResponse:\n    \"\"\"Update a student by ID.\"\"\"\n    try:\n        cursor = db.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE id = ?\", (id,))\n        if not cursor.fetchone():\n            raise HTTPException(status_code=404, detail=\"Student not found\")\n        \n        fields = []\n        values = []\n        if student_data.name is not None:\n            fields.append(\"name = ?\")\n            values.append(student_data.name)\n        if student_data.registration_number is not None:\n            fields.append(\"registration_number = ?\")\n            values.append(student_data.registration_number)\n        if student_data.course is not None:\n            fields.append(\"course = ?\")\n            values.append(student_data.course)\n\n        if not fields:\n            raise HTTPException(status_code=400, detail=\"No fields to update\")\n\n        values.append(id)\n        cursor.execute(f\"UPDATE students SET {', '.join(fields)} WHERE id = ?\", values)\n        db.commit()\n        \n        cursor.execute(\"SELECT * FROM students WHERE id = ?\", (id,))\n        row = cursor.fetchone()\n        return StudentResponse(id=row[\"id\"], name=row[\"name\"], registration_number=row[\"registration_number\"], course=row[\"course\"])\n    except Exception as e:\n        db.rollback()\n        logger.error(f\"Error updating student {id}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to update student\")\n\n@router.delete(\"/{id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_student(id: int, db: sqlite3.Connection = Depends(get_db)) -> Response:\n    \"\"\"Delete a student by ID.\"\"\"\n    try:\n        cursor = db.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE id = ?\", (id,))\n        if not cursor.fetchone():\n            raise HTTPException(status_code=404, detail=\"Student not found\")\n        \n        cursor.execute(\"DELETE FROM students WHERE id = ?\", (id,))\n        db.commit()\n        return Response(status_code=status.HTTP_204_NO_CONTENT)\n    except Exception as e:\n        db.rollback()\n        logger.error(f\"Error deleting student {id}: {e}\")\n        raise HTTPException(status_code=500, detail=\"Failed to delete student\")",
  "success": true,
  "error_message": null,
  "response_time_ms": 0.0,
  "token_count": null,
  "model_used": "gpt-4o-mini"
}