# TemplateRegistry API Contract

## Overview
Internal API contract for managing Jinja2 code generation templates used by SWEA agents.

## API Specification

### 1. Template Selection

**Method**: `select_template(entity_type: str, swea_type: str, requires_custom_logic: bool) -> Optional[TemplateMetadata]`

**Description**: Selects appropriate template based on entity characteristics and SWEA type.

**Request**:
```python
{
    "entity_type": "Student",
    "swea_type": "backend",
    "requires_custom_logic": false
}
```

**Response**:
```python
{
    "template_id": "backend_model_crud",
    "template_path": "backend/model_crud.py.j2",
    "entity_types": ["*"],
    "swea_type": "backend",
    "version": "1.0.0",
    "description": "SQLAlchemy model + Pydantic schema for standard CRUD entity",
    "requires_custom_logic": false
}
```

**Returns**: `TemplateMetadata` if suitable template found, `None` if LLM fallback required

**Selection Logic**:
1. If `requires_custom_logic=true`: Return None (LLM fallback)
2. Filter templates by `swea_type`
3. Check if `entity_type` in template's `entity_types` or `"*"` (wildcard)
4. Return first matching template

**Performance**: <1ms (in-memory lookup)

---

### 2. Template Rendering

**Method**: `render_template(template_id: str, input_data: TemplateInput) -> TemplateOutput`

**Description**: Renders Jinja2 template with provided entity data.

**Request**:
```python
{
    "template_id": "backend_model_crud",
    "input_data": {
        "entity_name": "Student",
        "attributes": [
            {"name": "name", "type": "string", "required": true, "default": null},
            {"name": "enrollment_date", "type": "date", "required": true, "default": null},
            {"name": "gpa", "type": "float", "required": true, "default": 0.0}
        ],
        "business_rules": [
            "GPA must be between 0.0 and 4.0",
            "Enrollment date cannot be in the future"
        ],
        "relationships": [
            {"related_entity": "Course", "type": "many-to-many", "field_name": "courses"}
        ],
        "standards_context": "# Backend Standards (Compressed)\n..."
    }
}
```

**Response**:
```python
{
    "generated_code": "# Generated by template backend_model_crud v1.0.0\nfrom sqlalchemy import ...",
    "template_id": "backend_model_crud",
    "template_version": "1.0.0",
    "warnings": [],
    "fallback_used": false
}
```

**Side Effects**:
- Template rendered using Jinja2 environment
- Custom filters applied (snake_case, pascal_case, python_type)
- Generated code includes template version comment for debugging

**Errors**:
- `TemplateRenderError`: If Jinja2 rendering fails (missing variable, syntax error)
  - Error logged with template_id and input_data
  - `fallback_used=true` returned with empty `generated_code`

**Performance**: <50ms for typical template (200 lines)

---

### 3. Template Registration

**Method**: `register_template(metadata: TemplateMetadata) -> None`

**Description**: Registers new or updated template in registry.

**Request**:
```python
{
    "metadata": {
        "template_id": "backend_custom_validation",
        "template_path": "backend/custom_validation.py.j2",
        "entity_types": ["Student", "Teacher"],
        "swea_type": "backend",
        "version": "1.1.0",
        "description": "Backend with complex cross-field validation",
        "requires_custom_logic": false
    }
}
```

**Response**: None (void)

**Side Effects**:
- Template metadata stored in registry dict
- Template file validated (exists, valid Jinja2 syntax)
- Previous version (if exists) backed up

**Errors**:
- `TemplateNotFoundError`: If template_path file doesn't exist
- `TemplateValidationError`: If Jinja2 syntax invalid

**Performance**: <10ms

---

### 4. Template Validation

**Method**: `validate_template(template_id: str) -> ValidationReport`

**Description**: Validates template by rendering with test data and checking output.

**Request**:
```python
{
    "template_id": "backend_model_crud"
}
```

**Response**:
```python
{
    "template_id": "backend_model_crud",
    "is_valid": true,
    "errors": [],
    "warnings": ["Line 47: Generated code exceeds 100 char limit"],
    "test_cases_passed": 5,
    "test_cases_failed": 0,
    "generated_sample": "# Sample output...\nfrom sqlalchemy import Column..."
}
```

**Test Cases**:
1. Minimal entity (1 attribute)
2. Standard entity (5 attributes, no relationships)
3. Entity with relationships (foreign keys, many-to-many)
4. Entity with validation rules
5. Entity with default values

**Performance**: <500ms (renders 5 test cases)

---

### 5. Get Available Templates

**Method**: `get_templates(swea_type: Optional[str] = None) -> List[TemplateMetadata]`

**Description**: Lists all registered templates, optionally filtered by SWEA type.

**Request**:
```python
{
    "swea_type": "backend"  # Optional
}
```

**Response**:
```python
[
    {
        "template_id": "backend_model_crud",
        "template_path": "backend/model_crud.py.j2",
        "entity_types": ["*"],
        "swea_type": "backend",
        "version": "1.0.0",
        "description": "SQLAlchemy model + Pydantic schema for standard CRUD entity",
        "requires_custom_logic": false
    },
    {
        "template_id": "backend_routes_crud",
        "template_path": "backend/routes_crud.py.j2",
        "entity_types": ["*"],
        "swea_type": "backend",
        "version": "1.0.0",
        "description": "FastAPI routes for create, read, update, delete, list operations",
        "requires_custom_logic": false
    }
]
```

**Performance**: <5ms

---

## Data Types

### TemplateInput
```python
@dataclass
class TemplateInput:
    entity_name: str
    attributes: List[Dict[str, Any]]  # [{name, type, required, default}]
    business_rules: List[str]
    relationships: List[Dict[str, str]]  # [{related_entity, type, field_name}]
    standards_context: str
```

### TemplateOutput
```python
@dataclass
class TemplateOutput:
    generated_code: str
    template_id: str
    template_version: str
    warnings: List[str]
    fallback_used: bool
```

### ValidationReport
```python
@dataclass
class ValidationReport:
    template_id: str
    is_valid: bool
    errors: List[str]
    warnings: List[str]
    test_cases_passed: int
    test_cases_failed: int
    generated_sample: str
```

---

## Jinja2 Custom Filters

### snake_case Filter
Converts string to snake_case for Python function/variable names.
```python
{{ entity_name | snake_case }}  # "Student" -> "student"
{{ "CourseEnrollment" | snake_case }}  # "course_enrollment"
```

### pascal_case Filter
Converts string to PascalCase for Python class names.
```python
{{ entity_name | pascal_case }}  # "student" -> "Student"
{{ "course_enrollment" | pascal_case }}  # "CourseEnrollment"
```

### python_type Filter
Maps attribute type to Python type hint.
```python
{{ attr.type | python_type }}
# Mappings:
# "string" -> "str"
# "integer" -> "int"
# "float" -> "float"
# "boolean" -> "bool"
# "date" -> "date"
# "datetime" -> "datetime"
# "list[string]" -> "List[str]"
```

---

## Error Handling

Template operations follow fallback pattern:
- **Template not found**: Return None from select_template, SWEA uses LLM
- **Render error**: Return TemplateOutput with `fallback_used=true`, SWEA uses LLM
- **Validation error**: Log error, template disabled until fixed

Template failures should never block entity generation.

---

## Template Versioning

Templates include version in generated code:
```python
# Generated by template backend_model_crud v1.0.0
# Template path: backend/model_crud.py.j2
# Generated at: 2025-12-23T15:30:00Z
```

This enables:
- Debugging template issues
- Tracking which code was template-generated vs LLM-generated
- Migrating to new template versions

---

## Monitoring

Template operations emit structured logs:
```json
{
    "event": "template_rendered",
    "template_id": "backend_model_crud",
    "entity_name": "Student",
    "render_time_ms": 42,
    "generated_lines": 156,
    "warnings_count": 0
}
```

Alert conditions:
- Template render failures > 10% (indicates template bug)
- Avg render time > 100ms (performance regression)
- Fallback usage > 40% (templates not covering common cases)
